# **技术架构总览 (Technical Architecture Overview)**

本文档是 `econ.simulator` 项目的技术实现总纲，旨在将 `docs/econ.design` 中的经济模型转化为一个**高度解耦、完全基于API交互**的微服务系统。

## **1. 核心设计原则**

*   **服务化 (Service-Oriented):** 系统的每个核心功能（状态管理、逻辑计算、日志记录等）都被封装成一个独立的、可通过API访问的服务。
*   **API作为契约 (API as Contract):** 服务之间**禁止**任何形式的直接代码调用或共享数据库连接。所有交互都必须通过定义良好的HTTP RESTful API进行。这是保证低耦合的最高准则。
*   **无状态逻辑 (Stateless Logic):** 所有执行计算的逻辑服务（如市场结算）自身不保存任何状态。它们接收数据，进行计算，然后返回结果，是纯粹的计算单元。
*   **集中式状态 (Centralized State):** 所有仿真世界的“状态”由唯一的**状态服务**进行管理，该服务是唯一有权读写Redis数据库的组件。
*   **异步通信 (Asynchronous Communication):** 所有服务均基于 `FastAPI` 构建，支持高并发的异步I/O，非常适合网络密集型的微服务架构。

## **2. 系统组件图 (微服务架构)**

```mermaid
graph TD
    subgraph "外部交互"
        A[玩家策略]
    end

    subgraph "核心微服务 (Core Microservices)"
        B[API网关 (API Gateway)]
        C[编排器服务 (Orchestrator)]
        D[状态服务 (State Service)]
        E[市场逻辑服务 (Market Logic Service)]
        F[代理人逻辑服务 (Agent Logic Service)]
        G[日志服务 (Logger Service)]
    end
    
    subgraph "基础设施"
        H[数据存储 (Redis)]
        I[数据仓库 (Parquet Files)]
    end

    A -- HTTP API --> B
    B -- HTTP API --> C
    
    C -- "1. 获取状态" --> D
    C -- "2. 调用逻辑" --> E
    C -- "3. 调用逻辑" --> F
    C -- "5. 更新状态" --> D
    C -- "6. 发送日志" --> G

    D -- 读/写 --> H
    E -- "计算" --> E
    F -- "计算" --> F
    G -- 写入 --> I

    style C fill:#f9f,stroke:#333,stroke-width:2px
    style D fill:#bbf,stroke:#333,stroke-width:2px
```

## **3. 核心服务职责**

*   **API网关 (API Gateway):**
    *   **职责:** 系统的统一入口，负责接收外部玩家的决策提交，并将其转发给**编排器服务**。它还负责初步的请求校验和安全认证。

*   **编排器服务 (Orchestrator Service):**
    *   **职责:** 仿真的“指挥家”。它驱动事件循环，但不执行具体业务逻辑。它通过调用其他服务来完成一个Tick的流程：从**状态服务**获取数据 -> 调用各种**逻辑服务**进行计算 -> 将结果发回**状态服务**进行更新 -> 通知**日志服务**记录数据。

*   **状态服务 (State Service):**
    *   **职责:** 仿真世界的“记忆中枢”。它是**唯一**可以与Redis数据库通信的服务。它提供了一套CRUD API，供其他服务安全地读写代理人、市场等的状态，从而将数据库实现完全隔离。

*   **逻辑服务 (Logic Services):**
    *   **职责:** 具体的“计算单元”。每个服务负责一块独立的业务逻辑（如`市场逻辑服务`负责所有市场的结算，`代理人逻辑服务`负责更新代理人行为）。它们是无状态的。

*   **日志服务 (Logger Service):**
    *   **职责:** 专用的“记录员”。它提供一个API端点来接收需要持久化的数据，并在内部将其批量写入到Parquet文件中。

## **4. 技术选型**

| 组件/目的      | 技术选型                               | 理由                                                                                             |
| -------------- | -------------------------------------- | ------------------------------------------------------------------------------------------------ |
| **服务框架**   | `FastAPI`                              | 所有微服务均使用FastAPI构建，统一技术栈，高性能，且易于定义清晰的API。                           |
| **核心数据存储** | `Redis` (由`状态服务`封装)             | 状态服务在内部使用Redis，但这对其他服务透明。                                                    |
| **服务间通信** | `HTTP` / `REST`                        | 简单、成熟、无处不在的通信协议，易于调试和理解。                                                 |
| **数据校验**   | `Pydantic`                             | 在所有服务的API边界上强制使用，确保数据在服务间流动的正确性和一致性。                            |
| **数值计算**   | `NumPy`, `Pandas`                      | 在需要批量计算的逻辑服务内部使用，以提升性能。                                                   |
| **离线数据格式** | `Apache Parquet` (由`日志服务`封装)    | 日志服务在内部使用Parquet，对其他服务透明。                                                      |

---
**下一步:**
*   [代码结构设计](./1_CODE_STRUCTURE.md)
*   [数据模型设计](./2_DATA_MODEL.md)
*   [API接口设计](./3_API_DESIGN.md)
