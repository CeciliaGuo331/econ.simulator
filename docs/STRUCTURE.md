# **经济仿真引擎 架构设计**

## **1. 引言与设计目标**

**1.1. 项目定位:**
本引擎旨在构建一个离散时间下的、多代理人（Multi-Agent）宏观经济仿真平台。其核心应用场景是作为一门宏观经济学相关课程的教学与实验平台，允许学生（玩家）通过编写或配置个体策略（Agent Strategy）来参与、影响并观察虚拟经济的动态演化。

**1.2. 核心设计原则:**
* **模块化 (Modularity):** 引擎核心逻辑与个体策略逻辑必须严格分离，通过清晰的API进行交互。
* **可扩展性 (Extensibility):** 架构应支持未来方便地增加新的代理人类型、市场机制或经济冲击。
* **可观测性 (Observability):** 系统的所有状态和数据都应易于记录、查询和可视化，为教学和分析提供支持。
* **确定性与可复现性 (Determinism & Reproducibility):** 在给定相同的初始条件和策略下，仿真结果应是可复现的（在不使用外部随机API如LLM的情况下）。

## **2. 系统架构分层**

本引擎建议采用分层架构，以实现关注点分离，提高系统的健壮性和灵活性。

* **第四层：策略/API层 (Strategy/API Layer)**
    * **描述:** 这是完全暴露给“玩家”的层面。玩家在此编写、配置或接入其代理人的决策逻辑。
    * **实现:** 可以是Python脚本、JSON配置文件，或封装了LLM API调用的模块。
    * **交互:** 引擎通过标准化的API从此层获取每个代理人的“决策”输出。

* **第三层：代理人层 (Agent Layer)**
    * **描述:** 仿真世界中所有独立个体的集合。每个代理人实例都包含其完整的“状态（State）”数据，并执行从策略层获取的“决策（Decision）”。
    * **核心:** 管理数以万计的个人、企业、银行实例的生命周期和状态数据。

* **第二层：市场与环境层 (Market & Environment Layer)**
    * **描述:** 这是代理人之间发生交互的“公共空间”。它不包含任何代理人，而是定义了交互的规则和结算的机制。
    * **组件:**
        * `商品市场 (Goods Market)`: 负责商品交易、价格发现。
        * `劳动力市场 (Labor Market)`: 负责职位发布、求职匹配、工资决定。
        * `金融市场 (Financial Market)`: 负责存贷款、债券发行与交易。
        * `宏观数据中心 (Macro Data Center)`: 负责计算和发布所有宏观经济指标。

* **第一层：核心引擎层 (Core Engine Layer)**
    * **描述:** 系统的心脏引擎。
    * **职责:**
        * `主事件循环 (Main Event Loop)`: 驱动仿真时间按“Tick”前进。
        * `时序调度器 (Scheduler)`: 严格规定在一个Tick内，各个层和模块的计算顺序。
        * `规则执行官 (Rule Enforcer)`: 确保所有代理人的行为都符合其“限制（Constraints）”。
        * `数据记录器 (Logger)`: 记录所有状态和事件，用于事后分析。

## **3. 时间与事件循环机制**

根据“**离散时间、每天计算三次**”的核心设定，我们定义如下时间结构：

* **纪元 (Epoch):** 一次完整的仿真运行。
* **天 (Day):** 宏观经济数据发布的基本周期。
* **时刻 (Tick):** 引擎计算的最小单位，**每天分为3个Ticks**。

**每日事件循环 (Daily Event Loop) - 示例流程:**

这种“一日三刻”的设计可以清晰地分离经济活动的不同阶段，避免因果混乱（例如，你不能在收到工资的同一瞬间就用它来消费）。

* **Tick 1: 生产与分配阶段 (早晨)**
    1.  **企业:** 根据前一天的市场信号和雇佣情况，进行生产，产成品进入库存。
    2.  **企业/政府:** 如果是支付工资日，需向其雇员支付前一天工作的**工资**。
    3.  **个人:** **如果收到工资**，更新自身资产状态。
    4.  **各代理人:** 基于更新后的状态，**制定本“天”的计划**（消费计划、生产计划、雇佣计划等）。

* **Tick 2: 交易与交互阶段 (下午)**
    1.  **劳动力市场:** 企业发布招聘岗位，个人进行求职/跳槽，市场进行匹配。
    2.  **商品市场:** 个人根据计划进行消费，企业出售库存商品。价格在此阶段形成。
    3.  **金融市场:** 个人进行储蓄，企业申请贷款，银行进行审批和资产配置。

* **Tick 3: 结算与更新阶段 (夜晚)**
    1.  **市场结算:** 所有市场的交易完成清算。
    2.  **代理人状态更新:** 所有代理人根据交易结果，最终更新其资产负债表（现金、库存、负债等）。
    3.  **宏观数据中心:** **计算并发布**当天的所有宏观经济指标（GDP、通胀率、失业率等）。这些数据将作为第二天Tick 1决策的重要依据。
    4.  **引擎:** 记录当天所有数据，检查仿真是否达到结束条件。

## **4. 代理人策略API与LLM集成设想**

* **API设计:** 引擎在需要代理人决策时，会调用一个标准化的函数，例如：
    `decision_object = player_strategy.get_decision(agent_state, market_data)`
    * `agent_state`: 该代理人可见的**私有**状态。
    * `market_data`: 该代理人可见的**公开**市场数据。

* **玩家的实现方式:**
    1.  **传统编程:** 玩家使用Python等语言，编写包含经济学逻辑的`if-else`和算法代码。
    2.  **LLM集成:** 玩家的`get_decision`函数内部调用大语言模型以辅助决策。具体流程例如:
        a.  将`agent_state`和`market_data`组合并**格式化**成一段给LLM的自然语言提示（Prompt）。
        b.  通过API**调用**一个大型语言模型（如GPT系列）。
        c.  **解析**LLM返回的自然语言回答，将其转换成引擎可以理解的、结构化的`decision_object`。

* **需注意的挑战:**
    * **性能与成本:** 大量代理人频繁调用LLM API会带来显著的时间延迟和费用成本。
    * **稳定性与可复现性:** LLM的回答具有随机性，可能导致仿真结果难以复现。同时，返回格式的不稳定也可能导致解析失败。
    * **“黑箱”行为:** 难以精确解释为什么LLM会做出某个特定的经济决策。
