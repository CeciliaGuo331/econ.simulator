"""Adapter utilities to present precomputed TickDecisions as per-agent AgentInterface.

This is a low-risk compatibility layer that allows gradual migration from the
centralized decision-generation flow to a per-agent observe/decide contract
expected by the docs.

Usage example:
    adapter = TickDecisionAgentAdapter(agent_kind=AgentKind.HOUSEHOLD, agent_id=1, decisions=decisions)
    obs = adapter.observe(world_state)
    dec = adapter.decide(obs)

The adapter does not perform IO and simply exposes the decisions that were
already generated by the baseline / script override pipeline.
"""

from __future__ import annotations

from typing import Any, Optional

from .interfaces import AgentInterface
from ..data_access.models import (
    WorldState,
    TickDecisions,
    AgentKind,
)


class TickDecisionAgentAdapter(AgentInterface):
    """Adapter that maps a precomputed TickDecisions to an AgentInterface for one agent.

    This is intended for use in tests or transitional code where you want to
    call per-agent observe/decide while preserving the existing centralized
    decision generation.
    """

    def __init__(
        self,
        agent_kind: AgentKind,
        agent_id: Optional[str | int],
        decisions: TickDecisions,
    ) -> None:
        self.agent_kind = agent_kind
        self.agent_id = agent_id
        self.decisions = decisions

    def observe(self, world_state: WorldState) -> Any:
        # Return a minimal observation: agent state snapshot + public market data
        if self.agent_kind == AgentKind.HOUSEHOLD:
            hid = int(self.agent_id) if self.agent_id is not None else None
            agent_state = world_state.households.get(hid) if hid is not None else None
        elif self.agent_kind == AgentKind.FIRM:
            agent_state = world_state.firm
        elif self.agent_kind == AgentKind.BANK:
            agent_state = world_state.bank
        elif self.agent_kind == AgentKind.GOVERNMENT:
            agent_state = world_state.government
        elif self.agent_kind == AgentKind.CENTRAL_BANK:
            agent_state = world_state.central_bank
        else:
            agent_state = None

        market = None
        try:
            market = world_state.get_public_market_data()
        except Exception:
            market = None

        return {"agent_state": agent_state, "market_data": market}

    def decide(self, observation: Any) -> Any:
        # Return the corresponding decision object from the TickDecisions bundle
        if self.agent_kind == AgentKind.HOUSEHOLD:
            hid = int(self.agent_id) if self.agent_id is not None else None
            if hid is None:
                return None
            return self.decisions.households.get(hid)
        elif self.agent_kind == AgentKind.FIRM:
            return getattr(self.decisions, "firm", None)
        elif self.agent_kind == AgentKind.BANK:
            return getattr(self.decisions, "bank", None)
        elif self.agent_kind == AgentKind.GOVERNMENT:
            return getattr(self.decisions, "government", None)
        elif self.agent_kind == AgentKind.CENTRAL_BANK:
            return getattr(self.decisions, "central_bank", None)
        return None
